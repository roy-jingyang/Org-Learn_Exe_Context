import pandas as pd

import ordinor.constants as const
from ordinor.execution_context.rule_based import dispersal, impurity
from ordinor.io import read_csv

def evaluate_ec(rl):
    COLS = [const.CASE_TYPE, const.ACTIVITY_TYPE, const.TIME_TYPE]
    # m_event_co : pandas.Series
    #     An array indexed by event ids, recording labels of the execution
    #     contexts to which the events belong to.
    mat_event_co = rl[COLS]
    for col in COLS:
        codes, _ = pd.factorize(mat_event_co[col])
        mat_event_co.loc[:, col] = codes.astype(str)
    mat_event_co.loc[:, '_co'] = mat_event_co[COLS].agg('-'.join, axis=1)
    mat_event_co.loc[:, '_co'], _ = pd.factorize(mat_event_co['_co'])
    m_event_co = mat_event_co['_co']
    # m_co_t : pandas.DataFrame
    #     An array indexed by execution context ids, recording labels of
    #     the case types, activity types, and time types of execution
    #     contexts, i.e., the column number is 3.
    m_co_t = mat_event_co.drop_duplicates(subset='_co')
    m_co_t = m_co_t.set_index('_co')
    m_co_t = m_co_t.astype(int)
    # m_event_r : pandas.Series
    #     An array indexed by event ids, recording ids of the resources who
    #     originated the events.
    m_event_r = rl[const.RESOURCE]
    imp = impurity(m_event_co, m_event_r)
    dis = dispersal(m_co_t, m_event_co, m_event_r)
    return dis, imp

if __name__ == '__main__':
    # Load data
    log = read_csv('../../PhD-thesis/om_discovery/input/sepsis.preprocessed.csv')

    # Filter out events with meaningless resource labels or without any resource label
    log = log[~log[const.RESOURCE].isin(['?'])]

    # Filter out cases without medical attribute information
    cases_rm = set()
    MED_ATTRS = [col for col in log.columns if col.startswith('case:Diagnostic')]
    MED_ATTRS += [
        'case:DisfuncOrg', 'case:Hypotensie', 'case:Hypoxie', 'case:InfectionSuspected', 'case:Infusion', 'case:Oligurie', 
        'case:SIRSCritHeartRate', 'case:SIRSCritLeucos', 'case:SIRSCritTachypnea', 'case:SIRSCritTemperature', 'case:SIRSCriteria2OrMore'
    ]
    for case, events in log.groupby(const.CASE_ID):
        for attr in MED_ATTRS:
            if events[attr].isna().all():
                cases_rm.add(case)
                break
    log = log[~log[const.CASE_ID].isin(cases_rm)]

    # Derive new columns based on the original ones
    # CT-related: N/A
    # AT-related: N/A
    # TT-related
    log.loc[:, 'year'] = log[const.TIMESTAMP].dt.year
    log.loc[:, 'month'] = log[const.TIMESTAMP].dt.month
    log.loc[:, 'weekday'] = log[const.TIMESTAMP].dt.day_name()

    ct_cands = ['NULL', 'case:returning', 'case:release_type'] + MED_ATTRS
    #at_cands = ['NULL', const.ACTIVITY, 'phase', 'category']
    at_cands = ['NULL', 'phase', 'category']
    #tt_cands = ['NULL', 'year', 'month', 'weekday']
    tt_cands = ['NULL', 'weekday']

    # Evaluate execution contexts (generated by ODT learning)
    from ordinor.execution_context import SearchMiner
    spec = {'type_def_attrs': {}}
    type_dim = ['CT', 'AT', 'TT']
    for i, l_type_def_attr in enumerate([ct_cands, at_cands, tt_cands]):
        for attr in l_type_def_attr:
            if attr != 'NULL':
                spec['type_def_attrs'][attr] = {'attr_type': 'categorical', 'attr_dim': type_dim[i]}
                # TODO: include numerical attributes

    miner = SearchMiner(log, spec)

    rl = miner.derive_resource_log(log)
    dis, imp = evaluate_ec(rl)
    print('Dispersal:\t{:.6f}'.format(dis))
    print('Impurity:\t{:.6f}'.format(imp))

    print(miner.type_dict)

