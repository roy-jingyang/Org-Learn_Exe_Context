import sys

import pandas as pd

import ordinor.constants as const
from ordinor.io import read_csv

from _search_algo_utils import evaluate_ec, print_log_stats, print_collated_results

if __name__ == '__main__':
    fn_log = sys.argv[1]
    variant = sys.argv[2]
    T0 = int(sys.argv[3])
    # Load data
    log = read_csv(fn_log)

    params = ['variant', 'T0', 'comment']
    for param, v in zip(params, sys.argv[2:]):
        print('{}={}'.format(param, v), end=', ')
    comment='T0-{}'.format(
        T0
    )
    print()

    # Filter out events with meaningless resource labels or without any resource label
    log = log[~log[const.RESOURCE].isin(['?'])]

    # Filter out cases without medical attribute information
    # NOTE: Exclude non-diagnostic attributes
    cases_rm = set()
    MED_ATTRS = [col for col in log.columns if col.startswith('case:Diagnostic')]
    for case, events in log.groupby(const.CASE_ID):
        for attr in MED_ATTRS:
            if events[attr].isna().all():
                cases_rm.add(case)
                break
    log = log[~log[const.CASE_ID].isin(cases_rm)]

    # Derive new columns based on the original ones
    # CT-related: N/A
    # AT-related: N/A
    # TT-related
    log.loc[:, 'year'] = log[const.TIMESTAMP].dt.year
    log.loc[:, 'month'] = log[const.TIMESTAMP].dt.month
    log.loc[:, 'weekday'] = log[const.TIMESTAMP].dt.day_name()

    for col in sorted(log.columns):
        print(col)
    exit()

    ct_cands = ['NULL', 'case:returning'] + MED_ATTRS
    at_cands = ['NULL', const.ACTIVITY]
    tt_cands = ['NULL', 'month', 'weekday']

    # Evaluate execution contexts (generated by search)
    from ordinor.execution_context import GreedySearchMiner, GreedyODTMiner, SASearchMiner
    spec = {'type_def_attrs': {}}
    type_dim = ['CT', 'AT', 'TT']
    for i, l_type_def_attr in enumerate([ct_cands, at_cands, tt_cands]):
        for attr in l_type_def_attr:
            if attr != 'NULL':
                spec['type_def_attrs'][attr] = {'attr_type': 'categorical', 'attr_dim': type_dim[i]}
                # TODO: include numerical attributes

    # Print log stats
    print_log_stats(log, spec)

    log.to_csv(fn_log + '.filtered.csv')
    exit()

    if variant == 'greedy':
        miner = GreedySearchMiner(
            log, spec, 
            init_method='zero',
            print_steps=True, trace_history=True,
            size_neighborhood=10, max_iter=T0
        )
        rl = miner.derive_resource_log(log)
    elif variant == 'odt':
        miner = GreedyODTMiner(
            log, spec, 
            print_steps=True, trace_history=True,
            size_neighborhood=1, max_iter=T0
        )
        rl = miner.derive_resource_log(log)
    elif variant == 'sa':
        miner = SASearchMiner(
            log, spec, 
            init_method='zero',
            print_steps=True, trace_history=True,
            size_neighborhood=15, T0=T0, Tmin=3e-4, alpha=0.95,
            restart_interval=50
        )
        rl = miner.derive_resource_log(log)
    elif variant == 'baseline':
        rl = []
        for i, row in log.iterrows():
            rl.append({
                const.RESOURCE: row[const.RESOURCE],
                const.CASE_TYPE: '-'.join(
                    str(row[x]) for x in ['case:returning'] + MED_ATTRS
                ),
                const.ACTIVITY_TYPE: row[const.ACTIVITY],
                const.TIME_TYPE: '-'.join(
                    str(row[x]) for x in ['month', 'weekday']
                )
            })
        rl = pd.DataFrame(rl)
    else:
        exit('Invalid parameter: {}'.format(variant))

    dis, imp = evaluate_ec(rl)

    print(miner.type_dict)
    
    ts_now = pd.Timestamp.now()
    fn_miner = '{}-sepsis_{}_{}.miner'.format(
        miner.__class__.__name__,
        ts_now.strftime('%Y%m%d-%H%M%S.%f'),
        comment
    )
    print('Output miner to {}'.format(fn_miner))
    with open(fn_miner, 'wb') as fout:
        miner.to_file(fout)

    print_collated_results(miner, dis, imp)

